<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DefaultApplicationManager.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Application Manager main Project</a> &gt; <a href="index.source.html" class="el_package">com.github.essobedo.appma.core</a> &gt; <span class="el_source">DefaultApplicationManager.java</span></div><h1>DefaultApplicationManager.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2016 essobedo.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 */
package com.github.essobedo.appma.core;

import com.github.essobedo.appma.core.config.ConfigFromProperties;
import com.github.essobedo.appma.core.config.ConfigurationFactory;
import com.github.essobedo.appma.core.io.Folder;
import com.github.essobedo.appma.core.progress.LogProgress;
import com.github.essobedo.appma.core.progress.StatusBar;
import com.github.essobedo.appma.core.util.Classpath;
import com.github.essobedo.appma.core.zip.UnzipTask;
import com.github.essobedo.appma.exception.ApplicationException;
import com.github.essobedo.appma.exception.TaskInterruptedException;
import com.github.essobedo.appma.spi.Manageable;
import com.github.essobedo.appma.spi.VersionManager;
import com.github.essobedo.appma.task.Task;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.io.Closeable;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.file.Files;
import java.util.Arrays;
import java.util.ServiceLoader;
import java.util.concurrent.Callable;
import java.util.concurrent.Future;
import java.util.concurrent.FutureTask;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Predicate;
import java.util.logging.Level;
import java.util.logging.Logger;
import javafx.application.Platform;
import javafx.event.Event;
import javafx.geometry.Rectangle2D;
import javafx.scene.Scene;
import javafx.stage.Screen;
import javafx.stage.Stage;

/**
 * The default implementation of {@link ApplicationManager}.
 *
 * @author Nicolas Filotto (nicolas.filotto@gmail.com)
 * @version $Id$
 * @since 1.0
 */
class DefaultApplicationManager implements ApplicationManager {

    /**
     * The logger of the class.
     */
<span class="fc" id="L72">    private static final Logger LOG = Logger.getLogger(DefaultApplicationManager.class.getName());</span>

    /**
     * The format of the error message to use in case of an illegal state while upgrading.
     */
    private static final String COULD_NOT_UPGRADE_ILLEGAL_STATE =
        &quot;Could not upgrade the application as the state is illegal: %s&quot;;

    /**
     * The arguments to pass to the application on initialization.
     */
    private final String[] arguments;

    /**
     * The root directory of the application.
     */
    private final File root;

    /**
     * The file in which the compressed content of the patch should be stored in case of an upgrade.
     */
    private final File patchTargetFile;

    /**
     * The folder in which the uncompressed content of the patch should be stored in case of an upgrade.
     */
    private final File patchContentTargetFolder;

    /**
     * The configuration of the application manager.
     */
    private Configuration configuration;

    /**
     * The current application.
     */
    private Manageable application;

    /**
     * The current state of the application.
     */
<span class="fc" id="L113">    private final AtomicReference&lt;ApplicationState&gt; state = new AtomicReference&lt;&gt;(ApplicationState.DESTROYED);</span>

    /**
     * The executor used to execute all the asynchronous tasks.
     */
<span class="fc" id="L118">    private final AsyncTaskExecutor executor = new AsyncTaskExecutor();</span>

    /**
     * The current stage.
     */
    private Stage stage;

    /**
     * The predicate to test to know if the application can exit or not.
     */
    private Predicate&lt;Void&gt; onCloseRequestPredicate;

    /**
     * Constructs a {@code DefaultApplicationManager} with the specified root folder and arguments.
     * @param root the root folder of the application.
     * @param arguments the arguments to pass to the application on initialization.
     * @throws ApplicationException The configuration could not be loaded.
     */
    DefaultApplicationManager(final File root, final String... arguments) throws ApplicationException {
<span class="fc" id="L137">        this(root, null, null, arguments);</span>
<span class="fc" id="L138">    }</span>

    /**
     * Constructs a {@code DefaultApplicationManager} with the specified root folder, patch file,
     * patch content folder and arguments.
     *
     * &lt;p&gt;&lt;i&gt;This constructor is for testing purpose only&lt;/i&gt;
     * @param root the root folder of the application.
     * @param patchTargetFile The patch file to use in case of an upgrade.
     * @param patchContentTargetFolder the folder to use to store the content of the patch in case
     * of an upgrade.
     * @param arguments the arguments to pass to the application on initialization.
     * @throws ApplicationException The configuration could not be loaded.
     */
    DefaultApplicationManager(final File root, final File patchTargetFile,
<span class="fc" id="L153">        final File patchContentTargetFolder, final String... arguments) throws ApplicationException {</span>
<span class="fc" id="L154">        this.root = root;</span>
<span class="fc" id="L155">        this.arguments = arguments;</span>
<span class="fc" id="L156">        this.patchTargetFile = patchTargetFile;</span>
<span class="fc" id="L157">        this.patchContentTargetFolder = patchContentTargetFolder;</span>
<span class="fc" id="L158">        loadConfiguration();</span>
<span class="fc" id="L159">    }</span>

    /**
     * Loads the configuration from the root directory.
     * @throws ApplicationException If the configuration could not be loaded.
     */
    private void loadConfiguration() throws ApplicationException {
<span class="fc" id="L166">        final ConfigurationFactory factory = new ConfigurationFactory(root);</span>
<span class="fc" id="L167">        setConfiguration(factory.create());</span>
<span class="fc" id="L168">    }</span>

    /**
     * Persists if needed the provided configuration and reloads the configuration from the
     * root directory.
     * @param configuration The configuration to store if needed.
     * @throws ApplicationException If the configuration could not be re-loaded.
     */
    private void reload(final Configuration configuration) throws ApplicationException {
<span class="fc" id="L177">        final String configurationName = ConfigurationFactory.getConfigurationName();</span>
<span class="fc" id="L178">        final File configFile = new File(root, configurationName);</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">        if (configuration == null) {</span>
<span class="pc bpc" id="L180" title="5 of 6 branches missed.">            if (configFile.exists() &amp;&amp; !configFile.delete() &amp;&amp; LOG.isLoggable(Level.WARNING)) {</span>
<span class="nc" id="L181">                LOG.log(Level.WARNING, String.format(&quot;The file '%s' could not be deleted&quot;,</span>
<span class="nc" id="L182">                    configFile.getAbsolutePath()));</span>
            }
<span class="fc" id="L184">            loadConfiguration();</span>
        } else {
            try {
<span class="fc" id="L187">                ConfigFromProperties.store(configuration, configFile);</span>
<span class="fc" id="L188">                setConfiguration(configuration);</span>
<span class="nc" id="L189">            } catch (IOException e) {</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">                if (LOG.isLoggable(Level.SEVERE)) {</span>
<span class="nc" id="L191">                    LOG.log(Level.SEVERE, &quot;The configuration could not be stored&quot;, e);</span>
                }
<span class="nc" id="L193">                loadConfiguration();</span>
<span class="fc" id="L194">            }</span>
        }
<span class="fc" id="L196">    }</span>

    /**
     * Sets the new configuration.
     * @param configuration The new configuration.
     */
    private void setConfiguration(final Configuration configuration) {
<span class="fc" id="L203">        synchronized (this) {</span>
<span class="fc" id="L204">            this.configuration = configuration;</span>
<span class="pc" id="L205">        }</span>
<span class="fc" id="L206">    }</span>

    /**
     * Gives the configuration of the application manager.
     * @return the configuration of the application manager.
     */
    private Configuration getConfiguration() {
<span class="fc" id="L213">        synchronized (this) {</span>
<span class="fc" id="L214">            return configuration;</span>
<span class="nc" id="L215">        }</span>
    }

    /**
     * Gives the current application.
     * @return the current application.
     */
    Manageable getApplication() {
<span class="fc" id="L223">        synchronized (this) {</span>
<span class="fc" id="L224">            return application;</span>
<span class="nc" id="L225">        }</span>
    }

    @Override
    public Stage getStage() {
<span class="fc" id="L230">        synchronized (this) {</span>
<span class="fc" id="L231">            return stage;</span>
<span class="nc" id="L232">        }</span>
    }

    @Override
    public void setOnCloseRequestPredicate(final Predicate&lt;Void&gt; predicate) {
<span class="nc" id="L237">        synchronized (this) {</span>
<span class="nc" id="L238">            this.onCloseRequestPredicate = predicate;</span>
<span class="nc" id="L239">        }</span>
<span class="nc" id="L240">    }</span>

    /**
     * @return The predicate to test to know if the application can exit or not.
     */
    private Predicate&lt;Void&gt; getOnCloseRequestPredicate() {
<span class="nc" id="L246">        synchronized (this) {</span>
<span class="nc" id="L247">            return onCloseRequestPredicate;</span>
<span class="nc" id="L248">        }</span>
    }

    /**
     * Creates the application.
     * @return The application that has been created by the application manager.
     * @throws ApplicationException if the application could not be created.
     */
    protected Manageable create() throws ApplicationException {
<span class="fc bfc" id="L257" title="All 2 branches covered.">        if (!state.compareAndSet(ApplicationState.DESTROYED, ApplicationState.CREATING)) {</span>
<span class="fc" id="L258">            throw new ApplicationException(String.format(</span>
<span class="fc" id="L259">                &quot;Could not create the application as the state is illegal: %s&quot;, state.get()));</span>
        }

<span class="fc" id="L262">        final ClassLoader classLoader = getClassLoader(getConfiguration());</span>
<span class="fc" id="L263">        final ServiceLoader&lt;Manageable&gt; loader = ServiceLoader.load(Manageable.class, classLoader);</span>
<span class="fc" id="L264">        Manageable application = null;</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">        for (final Manageable app : loader) {</span>
<span class="fc bfc" id="L266" title="All 2 branches covered.">            if (LOG.isLoggable(Level.FINE)) {</span>
<span class="fc" id="L267">                LOG.log(Level.FINE, String.format(&quot;The application '%s' version '%s' has ben found&quot;, app.name(),</span>
<span class="fc" id="L268">                    app.version()));</span>
            }
<span class="fc bfc" id="L270" title="All 2 branches covered.">            if (app.accept(arguments)) {</span>
<span class="fc" id="L271">                application = app;</span>
<span class="fc" id="L272">                break;</span>
<span class="pc bpc" id="L273" title="1 of 2 branches missed.">            } else if (LOG.isLoggable(Level.FINE)) {</span>
<span class="nc" id="L274">                LOG.log(Level.FINE, String.format(</span>
                    &quot;The application '%s' version '%s' is not compatible with the arguments '%s'&quot;,
<span class="nc" id="L276">                    app.name(), app.version(), Arrays.toString(arguments)));</span>
            }
<span class="fc" id="L278">        }</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">        if (application == null) {</span>
<span class="fc" id="L280">            throw new ApplicationException(&quot;Could not find any compliant application&quot;);</span>
        }
<span class="fc" id="L282">        synchronized (this) {</span>
<span class="fc" id="L283">            this.application = application;</span>
<span class="pc" id="L284">        }</span>
<span class="fc" id="L285">        state.set(ApplicationState.CREATED);</span>
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">        if (LOG.isLoggable(Level.INFO)) {</span>
<span class="fc" id="L287">            LOG.log(Level.INFO, String.format(&quot;The application '%s' version '%s' has ben found&quot;, application.name(),</span>
<span class="fc" id="L288">                application.version()));</span>
        }
<span class="fc" id="L290">        return application;</span>
    }

    /**
     * Initializes the application.
     * @return The {@link Scene} of the initialized application in case of a Java FX application
     * or {@code null} otherwise.
     * @throws ApplicationException if the application could not be created.
     */
    protected Scene init() throws ApplicationException {
<span class="fc bfc" id="L300" title="All 2 branches covered.">        if (!state.compareAndSet(ApplicationState.CREATED, ApplicationState.INITIALIZING)) {</span>
<span class="fc" id="L301">            throw new ApplicationException(String.format(</span>
<span class="fc" id="L302">                &quot;Could not init the application as the state is illegal: %s&quot;, state.get()));</span>
        }

<span class="fc" id="L305">        final Manageable application = getApplication();</span>
<span class="fc" id="L306">        final ClassLoader contextCL = Thread.currentThread().getContextClassLoader();</span>
        final Scene scene;
        try {
<span class="fc" id="L309">            Thread.currentThread().setContextClassLoader(application.getClass().getClassLoader());</span>
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">            if (LOG.isLoggable(Level.INFO)) {</span>
<span class="fc" id="L311">                LOG.log(Level.INFO, String.format(&quot;Init the application '%s' version '%s'&quot;, application.name(),</span>
<span class="fc" id="L312">                    application.version()));</span>
            }
<span class="fc" id="L314">            scene = application.init(this, arguments);</span>
<span class="fc" id="L315">            state.set(ApplicationState.INITIALIZED);</span>

<span class="fc" id="L317">        } catch (ApplicationException e) {</span>
<span class="fc" id="L318">            state.set(ApplicationState.UNKNOWN);</span>
<span class="fc" id="L319">            throw e;</span>
<span class="fc" id="L320">        } catch (RuntimeException e) {</span>
<span class="fc" id="L321">            state.set(ApplicationState.UNKNOWN);</span>
<span class="fc" id="L322">            throw new ApplicationException(&quot;Could not init the application&quot;, e);</span>
        } finally {
<span class="fc" id="L324">            Thread.currentThread().setContextClassLoader(contextCL);</span>
<span class="fc" id="L325">        }</span>
<span class="fc" id="L326">        return scene;</span>
    }

    /**
     * Creates the {@link ClassLoader} corresponding to the specified {@link Configuration}.
     * @param configuration The configuration to use to create the {@link ClassLoader}.
     * @return The {@link ClassLoader} corresponding to the specified {@link Configuration}.
     * @throws ApplicationException if the {@link ClassLoader} could not be created.
     */
    private ClassLoader getClassLoader(final Configuration configuration) throws ApplicationException {
<span class="fc" id="L336">        final URL[] urls = configuration.getClasspathAsUrls();</span>
<span class="fc" id="L337">        return new URLClassLoader(urls, getClass().getClassLoader());</span>
    }

    /**
     * Destroys the application.
     * @throws ApplicationException if the application could not be created.
     */
    protected void destroy() throws ApplicationException {
<span class="fc bfc" id="L345" title="All 2 branches covered.">        if (!state.compareAndSet(ApplicationState.INITIALIZED, ApplicationState.DESTROYING)) {</span>
<span class="fc" id="L346">            throw new ApplicationException(String.format(</span>
<span class="fc" id="L347">                &quot;Could not destroy the application as the state is illegal: %s&quot;, state.get()));</span>
        }
<span class="fc" id="L349">        final Manageable application = getApplication();</span>
<span class="fc" id="L350">        final ClassLoader contextCL = Thread.currentThread().getContextClassLoader();</span>
        try {
<span class="fc" id="L352">            Thread.currentThread().setContextClassLoader(application.getClass().getClassLoader());</span>
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">            if (LOG.isLoggable(Level.INFO)) {</span>
<span class="fc" id="L354">                LOG.log(Level.INFO, String.format(&quot;Destroy the application '%s' version '%s'&quot;, application.name(),</span>
<span class="fc" id="L355">                    application.version()));</span>
            }
<span class="pc bpc" id="L357" title="1 of 4 branches missed.">            if (getStage() != null &amp;&amp; application.icon() != null) {</span>
<span class="nc" id="L358">                Platform.runLater(() -&gt; getStage().getIcons().removeAll(application.icon()));</span>
            }
<span class="fc" id="L360">            application.destroy();</span>
<span class="fc" id="L361">            closeClasspath(getConfiguration());</span>
<span class="fc" id="L362">            close(application.getClass().getClassLoader());</span>
<span class="fc" id="L363">            synchronized (this) {</span>
<span class="fc" id="L364">                this.application = null;</span>
<span class="pc" id="L365">            }</span>
<span class="fc" id="L366">            state.set(ApplicationState.DESTROYED);</span>

<span class="fc" id="L368">        } catch (ApplicationException e) {</span>
<span class="fc" id="L369">            state.set(ApplicationState.UNKNOWN);</span>
<span class="fc" id="L370">            throw e;</span>
<span class="fc" id="L371">        } catch (RuntimeException e) {</span>
<span class="fc" id="L372">            state.set(ApplicationState.UNKNOWN);</span>
<span class="fc" id="L373">            throw new ApplicationException(&quot;Could not destroy the application&quot;, e);</span>
        } finally {
<span class="fc" id="L375">            Thread.currentThread().setContextClassLoader(contextCL);</span>
<span class="fc" id="L376">        }</span>
<span class="fc" id="L377">    }</span>

    /**
     * Closes all the resources corresponding to the classpath.
     * @param configuration The configuration from which it extracts the URLs corresponding to the classpath.
     */
    private void closeClasspath(final Configuration configuration) {
<span class="pc bpc" id="L384" title="1 of 2 branches missed.">        if (configuration == null) {</span>
<span class="nc" id="L385">            return;</span>
        }
        try {
<span class="fc" id="L388">            final Classpath classpath = new Classpath(configuration.getClasspathAsUrls());</span>
<span class="fc" id="L389">            classpath.release();</span>
<span class="nc" id="L390">        } catch (ApplicationException e) {</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">            if (LOG.isLoggable(Level.WARNING)) {</span>
<span class="nc" id="L392">                LOG.log(Level.WARNING, &quot;Could not close the jar files used by the classloader&quot;, e);</span>
            }
<span class="fc" id="L394">        }</span>
<span class="fc" id="L395">    }</span>

    /**
     * Closes the classloader if possible in order to properly release the resources.
     * @param classLoader The classloader to close.
     */
    @SuppressWarnings(&quot;PMD.DoNotCallGarbageCollectionExplicitly&quot;)
    @SuppressFBWarnings(value = &quot;DM_GC&quot;, justification = &quot;Needed to properly release the jar files&quot;)
    private void close(final ClassLoader classLoader) {
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">        if (classLoader == null) {</span>
<span class="nc" id="L405">            return;</span>
        }
<span class="pc bpc" id="L407" title="1 of 2 branches missed.">        if (classLoader instanceof Closeable) {</span>
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">            if (LOG.isLoggable(Level.INFO)) {</span>
<span class="fc" id="L409">                LOG.log(Level.INFO, &quot;Closing the classloader&quot;);</span>
            }
            try {
<span class="fc" id="L412">                ((Closeable) classLoader).close();</span>
<span class="nc" id="L413">            } catch (IOException e) {</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">                if (LOG.isLoggable(Level.WARNING)) {</span>
<span class="nc" id="L415">                    LOG.log(Level.WARNING, &quot;Could not close properly the classloader&quot;, e);</span>
                }
            } finally {
                // Ensure that there is no more references relying on this classloader.
<span class="pc" id="L419">                System.gc();</span>
<span class="pc" id="L420">            }</span>
        }
<span class="fc" id="L422">    }</span>

    @Override
    public Task&lt;String&gt; checkForUpdate() throws ApplicationException {
<span class="fc" id="L426">        final Manageable application = getApplication();</span>
<span class="fc bfc" id="L427" title="All 2 branches covered.">        if (application == null) {</span>
<span class="fc" id="L428">            throw new ApplicationException(&quot;Could not check for update as there is no application running&quot;);</span>
        }
<span class="fc" id="L430">        final ClassLoader contextCL = Thread.currentThread().getContextClassLoader();</span>
        try {
<span class="fc" id="L432">            Thread.currentThread().setContextClassLoader(application.getClass().getClassLoader());</span>
<span class="fc" id="L433">            final VersionManager versionManager = getVersionManager(application.getClass().getName(),</span>
<span class="fc" id="L434">                application.getClass().getClassLoader());</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">            if (versionManager == null) {</span>
<span class="fc" id="L436">                throw new ApplicationException(&quot;No version manager could be found&quot;);</span>
            }
<span class="pc bpc" id="L438" title="1 of 2 branches missed.">            if (LOG.isLoggable(Level.INFO)) {</span>
<span class="fc" id="L439">                LOG.log(Level.INFO, String.format(&quot;Checking for update for the application '%s' version '%s'&quot;,</span>
<span class="fc" id="L440">                    application.name(),</span>
<span class="fc" id="L441">                    application.version()));</span>
            }
<span class="fc" id="L443">            return versionManager.check(application);</span>
<span class="fc" id="L444">        } catch (ApplicationException e) {</span>
<span class="pc bpc" id="L445" title="1 of 2 branches missed.">            if (LOG.isLoggable(Level.SEVERE)) {</span>
<span class="fc" id="L446">                LOG.log(Level.SEVERE, &quot;Could not check for update&quot;, e);</span>
            }
<span class="fc" id="L448">            throw e;</span>
        } finally {
<span class="fc" id="L450">            Thread.currentThread().setContextClassLoader(contextCL);</span>
        }
    }

    @Override
    public Future&lt;Void&gt; upgrade() {
<span class="fc" id="L456">        final Callable&lt;Void&gt; task = () -&gt; {</span>
            try {
<span class="fc" id="L458">                doUpgrade();</span>
<span class="fc" id="L459">            } catch (ApplicationException e) {</span>
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">                if (LOG.isLoggable(Level.SEVERE)) {</span>
<span class="fc" id="L461">                    LOG.log(Level.SEVERE, e.getMessage(), e);</span>
                }
<span class="fc" id="L463">                exit();</span>
<span class="fc" id="L464">                throw e;</span>
<span class="fc" id="L465">            }</span>
<span class="fc" id="L466">            return null;</span>
        };
<span class="fc" id="L468">        final FutureTask&lt;Void&gt; future = new FutureTask&lt;&gt;(task);</span>
<span class="fc" id="L469">        executor.execute(future);</span>
<span class="fc" id="L470">        return future;</span>
    }

    /**
     * Upgrades the application.
     * @throws ApplicationException if the application could not be upgraded.
     */
    void doUpgrade() throws ApplicationException {
<span class="fc bfc" id="L478" title="All 2 branches covered.">        if (state.get() != ApplicationState.INITIALIZED) {</span>
<span class="fc" id="L479">            throw new ApplicationException(String.format(COULD_NOT_UPGRADE_ILLEGAL_STATE, state.get()));</span>
        }
<span class="fc" id="L481">        final Manageable application = getApplication();</span>
<span class="pc bpc" id="L482" title="1 of 2 branches missed.">        if (application == null) {</span>
<span class="nc" id="L483">            throw new ApplicationException(String.format(COULD_NOT_UPGRADE_ILLEGAL_STATE, state.get()));</span>
        }
<span class="fc" id="L485">        final String className = application.getClass().getName();</span>
<span class="fc" id="L486">        final VersionManager versionManager = getVersionManager(className,</span>
<span class="fc" id="L487">                                                                application.getClass().getClassLoader());</span>
<span class="fc bfc" id="L488" title="All 2 branches covered.">        if (versionManager == null) {</span>
<span class="fc" id="L489">            throw new ApplicationException(&quot;No version manager could be found&quot;);</span>
        }
<span class="fc" id="L491">        final File patchFolder = getPatchContent(application, versionManager);</span>
<span class="fc" id="L492">        final String oldVersion = application.version();</span>
<span class="fc" id="L493">        destroy();</span>
<span class="fc" id="L494">        applyNShow(className, patchFolder, oldVersion);</span>
<span class="fc" id="L495">    }</span>

    /**
     * Applies the patch and launches the upgraded application.
     * @param className the name of the class of the application to upgrade.
     * @param patchFolder the folder that contains the content of the patch.
     * @param oldVersion the previous version of the application.
     * @throws ApplicationException In case an error occurs.
     */
    private void applyNShow(final String className, final File patchFolder, final String oldVersion)
                            throws ApplicationException {
<span class="pc bpc" id="L506" title="1 of 2 branches missed.">        if (!state.compareAndSet(ApplicationState.DESTROYED, ApplicationState.UPGRADING)) {</span>
<span class="nc" id="L507">            throw new ApplicationException(String.format(COULD_NOT_UPGRADE_ILLEGAL_STATE, state.get()));</span>
        }
<span class="pc bpc" id="L509" title="2 of 4 branches missed.">        if (patchFolder == null || !applyPatch(className, patchFolder, oldVersion)) {</span>
<span class="nc" id="L510">            return;</span>
        }
<span class="pc bpc" id="L512" title="1 of 2 branches missed.">        if (!state.compareAndSet(ApplicationState.UPGRADING, ApplicationState.DESTROYED)) {</span>
<span class="nc" id="L513">            throw new ApplicationException(String.format(COULD_NOT_UPGRADE_ILLEGAL_STATE, state.get()));</span>
        }
<span class="fc" id="L515">        create();</span>
<span class="pc bpc" id="L516" title="1 of 4 branches missed.">        if (getStage() != null &amp;&amp; getApplication().icon() != null) {</span>
<span class="nc" id="L517">            Platform.runLater(() -&gt; getStage().getIcons().add(getApplication().icon()));</span>
        }
<span class="fc" id="L519">        initNShow();</span>
<span class="fc" id="L520">    }</span>

    /**
     * Triggers an initialization of the application. It will be done asynchronously.
     * @param stage the stage to use to initialize the application.
     * @param callbackOnError callback to use in case of an error.
     * @return The {@link Future} object allowing to be notified once the task is over.
     */
    Future&lt;Void&gt; asyncInitNShow(final Stage stage, final Runnable callbackOnError) {
<span class="fc" id="L529">        final Callable&lt;Void&gt; task = () -&gt; {</span>
            try {
<span class="fc" id="L531">                synchronized (this) {</span>
<span class="fc" id="L532">                    this.stage = stage;</span>
<span class="pc" id="L533">                }</span>
<span class="fc" id="L534">                initNShow();</span>
<span class="fc" id="L535">            } catch (ApplicationException e) {</span>
<span class="pc bpc" id="L536" title="1 of 2 branches missed.">                if (callbackOnError != null) {</span>
<span class="fc" id="L537">                    Platform.runLater(callbackOnError::run);</span>
                }
<span class="pc bpc" id="L539" title="1 of 2 branches missed.">                if (LOG.isLoggable(Level.SEVERE)) {</span>
<span class="fc" id="L540">                    LOG.log(Level.SEVERE, e.getMessage(), e);</span>
                }
<span class="fc" id="L542">                throw e;</span>
<span class="fc" id="L543">            }</span>
<span class="fc" id="L544">            return null;</span>
        };
<span class="fc" id="L546">        final FutureTask&lt;Void&gt; future = new FutureTask&lt;&gt;(task);</span>
<span class="fc" id="L547">        executor.execute(future);</span>
<span class="fc" id="L548">        return future;</span>
    }

    /**
     * Initializes and shows the application.
     * @throws ApplicationException in case the application could not be initialized.
     */
    private void initNShow() throws ApplicationException {
<span class="fc" id="L556">        final Manageable application = getApplication();</span>
<span class="fc" id="L557">        final Scene scene = init();</span>
<span class="fc bfc" id="L558" title="All 2 branches covered.">        if (getStage() != null) {</span>
<span class="fc" id="L559">            Platform.runLater(() -&gt; showApplication(application, scene));</span>
        }
<span class="fc" id="L561">    }</span>

    /**
     * Shows the application in the middle of the screen.
     * @param application the application to show
     * @param scene the scene to display in the middle of the screen.
     */
    private void showApplication(final Manageable application, final Scene scene) {
<span class="fc" id="L569">        final ClassLoader contextCL = Thread.currentThread().getContextClassLoader();</span>
        try {
<span class="fc" id="L571">            Thread.currentThread().setContextClassLoader(application.getClass().getClassLoader());</span>
<span class="fc" id="L572">            final Stage primaryStage = getStage();</span>
<span class="fc" id="L573">            primaryStage.setResizable(true);</span>
<span class="fc" id="L574">            primaryStage.setOnCloseRequest(event -&gt; {</span>
<span class="nc" id="L575">                final Predicate&lt;Void&gt; predicate = getOnCloseRequestPredicate();</span>
<span class="nc bnc" id="L576" title="All 4 branches missed.">                if (predicate == null || predicate.test(null)) {</span>
                    // Can exit
<span class="nc" id="L578">                    onExit();</span>
                } else {
                    // Discard the event to prevent closing the window.
<span class="nc" id="L581">                    event.consume();</span>
                }
<span class="nc" id="L583">            });</span>
<span class="fc" id="L584">            primaryStage.setScene(scene);</span>
<span class="fc" id="L585">            final Rectangle2D primScreenBounds = Screen.getPrimary().getVisualBounds();</span>
<span class="fc" id="L586">            primaryStage.setX((primScreenBounds.getWidth() - primaryStage.getWidth()) / 2);</span>
<span class="fc" id="L587">            primaryStage.setY((primScreenBounds.getHeight() - primaryStage.getHeight()) / 2);</span>
        } finally {
<span class="pc" id="L589">            Thread.currentThread().setContextClassLoader(contextCL);</span>
<span class="fc" id="L590">        }</span>
<span class="fc" id="L591">    }</span>

    /**
     * Applies the patch.
     * @param className The name of the application to upgrade.
     * @param patchFolder the folder containing the content of the patch.
     * @param oldVersion the previous version of the application.
     * @return {@code true} if the patch could be applied, {@code false} otherwise.
     * @throws ApplicationException in case the patch could not be applied.
     */
    private boolean applyPatch(final String className, final File patchFolder,
                               final String oldVersion) throws ApplicationException {
<span class="fc" id="L603">        final ClassLoader contextCL = Thread.currentThread().getContextClassLoader();</span>
<span class="fc" id="L604">        Configuration config = null;</span>
<span class="fc" id="L605">        ClassLoader classLoader = null;</span>
        try {
<span class="fc" id="L607">            final ConfigurationFactory factory = new ConfigurationFactory(patchFolder);</span>
<span class="fc" id="L608">            config = factory.create();</span>
<span class="fc" id="L609">            classLoader = getClassLoader(config);</span>
<span class="fc" id="L610">            Thread.currentThread().setContextClassLoader(classLoader);</span>
<span class="fc" id="L611">            final VersionManager versionManager = getVersionManager(className, classLoader);</span>
<span class="pc bpc" id="L612" title="1 of 2 branches missed.">            if (versionManager == null) {</span>
<span class="nc" id="L613">                throw new ApplicationException(&quot;No version manager could be found&quot;);</span>
            }
<span class="fc" id="L615">            final Configuration configuration = executeTask(&quot;Applying the patch&quot;,</span>
<span class="fc" id="L616">                ((VersionManager&lt;?&gt;) versionManager).upgrade(patchFolder, root, oldVersion));</span>
<span class="fc" id="L617">            reload(configuration);</span>
<span class="nc" id="L618">        } catch (TaskInterruptedException e) {</span>
<span class="nc bnc" id="L619" title="All 2 branches missed.">            if (LOG.isLoggable(Level.FINE)) {</span>
<span class="nc" id="L620">                LOG.log(Level.FINE, &quot;The task has been interrupted&quot;, e);</span>
            }
<span class="nc" id="L622">            exit();</span>
<span class="nc" id="L623">            return false;</span>
<span class="nc" id="L624">        } catch (ApplicationException e) {</span>
<span class="nc" id="L625">            state.set(ApplicationState.UNKNOWN);</span>
<span class="nc" id="L626">            throw e;</span>
<span class="nc" id="L627">        } catch (RuntimeException e) {</span>
<span class="nc" id="L628">            state.set(ApplicationState.UNKNOWN);</span>
<span class="nc" id="L629">            throw new ApplicationException(&quot;Could not upgrade the application&quot;, e);</span>
        } finally {
<span class="pc" id="L631">            Thread.currentThread().setContextClassLoader(contextCL);</span>
<span class="pc" id="L632">            closeClasspath(config);</span>
<span class="pc" id="L633">            close(classLoader);</span>
<span class="pc" id="L634">            final Folder folder = new Folder(patchFolder);</span>
<span class="pc" id="L635">            folder.delete();</span>
<span class="pc" id="L636">        }</span>
<span class="fc" id="L637">        return true;</span>
    }

    /**
     * Gets the content of the patch and stores it into a folder.
     * @param application the application for which we want to get the patch.
     * @param versionManager the version manager to use to get the content of the patch.
     * @return a {@code File} corresponding to the folder that contains the content of the patch.
     * @throws ApplicationException if the content of the patch could not be retrieved.
     */
    private File getPatchContent(final Manageable application, final VersionManager versionManager)
                                 throws ApplicationException {
        File destFolder;
<span class="fc" id="L650">        final ClassLoader contextCL = Thread.currentThread().getContextClassLoader();</span>
<span class="fc" id="L651">        File file2Delete = null;</span>
        try {
<span class="fc" id="L653">            Thread.currentThread().setContextClassLoader(application.getClass().getClassLoader());</span>
<span class="fc" id="L654">            final File zipFile = getPatchTargetFile();</span>
<span class="fc" id="L655">            file2Delete = zipFile;</span>
<span class="pc" id="L656">            try (OutputStream out = new FileOutputStream(zipFile)) {</span>
<span class="fc" id="L657">                executeTask(String.format(&quot;Getting the new version of the application '%s'&quot;,</span>
<span class="fc" id="L658">                    application.name()), versionManager.store(application, out));</span>
<span class="pc bpc" id="L659" title="6 of 8 branches missed.">            }</span>
<span class="fc" id="L660">            destFolder = getPatchContentTargetFolder();</span>
<span class="fc" id="L661">            final Task&lt;Void&gt; unzip = new UnzipTask(zipFile, destFolder);</span>
<span class="fc" id="L662">            executeTask(&quot;Unzipping the patch&quot;, unzip);</span>
<span class="nc" id="L663">        } catch (TaskInterruptedException e) {</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">            if (LOG.isLoggable(Level.FINE)) {</span>
<span class="nc" id="L665">                LOG.log(Level.FINE, &quot;The task has been interrupted&quot;, e);</span>
            }
<span class="nc" id="L667">            exit();</span>
<span class="nc" id="L668">            destFolder = null;</span>
<span class="nc" id="L669">        } catch (ApplicationException e) {</span>
<span class="nc" id="L670">            state.set(ApplicationState.UNKNOWN);</span>
<span class="nc" id="L671">            throw e;</span>
<span class="nc" id="L672">        } catch (RuntimeException | IOException e) {</span>
<span class="nc" id="L673">            state.set(ApplicationState.UNKNOWN);</span>
<span class="nc" id="L674">            throw new ApplicationException(&quot;Could not upgrade the application&quot;, e);</span>
        } finally {
<span class="pc bpc" id="L676" title="16 of 18 branches missed.">            if (file2Delete != null &amp;&amp; !file2Delete.delete() &amp;&amp; LOG.isLoggable(Level.WARNING)) {</span>
<span class="nc" id="L677">                LOG.log(Level.WARNING, String.format(&quot;The file '%s' could not be deleted&quot;,</span>
<span class="nc" id="L678">                    file2Delete.getAbsolutePath()));</span>
            }
<span class="pc" id="L680">            Thread.currentThread().setContextClassLoader(contextCL);</span>
<span class="pc" id="L681">        }</span>
<span class="fc" id="L682">        return destFolder;</span>
    }

    /**
     * Gives the folder that will contain the content of the patch.
     * @return the folder that will contain the content of the patch.
     * @throws IOException in case the temporary directory could not be created.
     */
    private File getPatchContentTargetFolder() throws IOException {
<span class="fc bfc" id="L691" title="All 2 branches covered.">        if (patchContentTargetFolder == null) {</span>
<span class="fc" id="L692">            return new File(Files.createTempDirectory(&quot;upgrade&quot;).toString());</span>
        } else {
<span class="fc" id="L694">            return patchContentTargetFolder;</span>
        }
    }

    /**
     * Gives the file that will contain the patch.
     * @return the file that will contain the patch.
     * @throws IOException in case the temporary file could not be created.
     */
    private File getPatchTargetFile() throws IOException {
<span class="fc bfc" id="L704" title="All 2 branches covered.">        if (patchTargetFile == null) {</span>
<span class="fc" id="L705">            return File.createTempFile(&quot;upgrade&quot;, &quot;tmp&quot;);</span>
        } else {
<span class="fc" id="L707">            return patchTargetFile;</span>
        }
    }

    /**
     * Executes the specified task and use {@link LogProgress} or {@link StatusBar} to
     * provide information about how the task is progressing. If the application is
     * a Java FX application, it will use the {@link StatusBar} otherwise it will use the
     * {@link LogProgress}.
     * @param messageInfo the info message to log before executing the task.
     * @param task the task to execute.
     * @param &lt;T&gt; the return type of the task to execute.
     * @return The result of the task
     * @throws ApplicationException if the task fails.
     * @throws TaskInterruptedException if the task has been interrupted.
     */
    private &lt;T&gt; T executeTask(final String messageInfo, final Task&lt;T&gt; task)
                                throws ApplicationException, TaskInterruptedException {
<span class="pc bpc" id="L725" title="1 of 2 branches missed.">        if (LOG.isLoggable(Level.INFO)) {</span>
<span class="fc" id="L726">            LOG.log(Level.INFO, messageInfo);</span>
        }
<span class="fc bfc" id="L728" title="All 2 branches covered.">        if (getStage() == null) {</span>
<span class="fc" id="L729">            new LogProgress(task);</span>
        } else {
<span class="fc" id="L731">            final StatusBar bar = new StatusBar(task);</span>
<span class="fc" id="L732">            final Scene scene = new Scene(bar, 300.0d, 150.0d);</span>

<span class="fc" id="L734">            Platform.runLater(() -&gt;  showStatusWindow(scene));</span>
        }
<span class="fc" id="L736">        return task.execute();</span>
    }

    /**
     * Show the window providing the status of a task in the middle of the screen.
     * @param scene the window to display in the middle of the screen.
     */
    private void showStatusWindow(final Scene scene) {
<span class="fc" id="L744">        final Stage primaryStage = getStage();</span>
<span class="fc" id="L745">        primaryStage.setResizable(false);</span>
<span class="fc" id="L746">        primaryStage.setOnCloseRequest(Event::consume);</span>
<span class="fc" id="L747">        primaryStage.setScene(scene);</span>
<span class="fc" id="L748">        final Rectangle2D primScreenBounds = Screen.getPrimary().getVisualBounds();</span>
<span class="fc" id="L749">        primaryStage.setX((primScreenBounds.getWidth() - primaryStage.getWidth()) / 2);</span>
<span class="fc" id="L750">        primaryStage.setY((primScreenBounds.getHeight() - primaryStage.getHeight()) / 2);</span>
<span class="fc" id="L751">    }</span>

    /**
     * Gives the version manager that could be found using the given class loader and that matches
     * with the specified full qualified name of the application.
     * @param className the full qualified name of the application for which we look for a version manager.
     * @param classLoader the classloader to use to find the version manager.
     * @return the version manager that matches with the specified criteria, {@code null} if none could
     * be found.
     * @throws ApplicationException if an error occurs while looking for a version manager.
     */
    private VersionManager&lt;?&gt; getVersionManager(final String className, final ClassLoader classLoader)
        throws ApplicationException {
<span class="fc" id="L764">        final ServiceLoader&lt;VersionManager&gt; loader = ServiceLoader.load(VersionManager.class, classLoader);</span>
<span class="fc bfc" id="L765" title="All 2 branches covered.">        for (final VersionManager versionManager : loader) {</span>
<span class="fc bfc" id="L766" title="All 2 branches covered.">            if (LOG.isLoggable(Level.FINE)) {</span>
<span class="fc" id="L767">                LOG.log(Level.FINE, String.format(&quot;The version manager '%s' has ben found&quot;,</span>
<span class="fc" id="L768">                    versionManager.getClass().getName()));</span>
<span class="fc" id="L769">                LOG.log(Level.FINE, String.format(&quot;The version manager '%s' has '%s' generic interfaces&quot;,</span>
<span class="fc" id="L770">                    versionManager.getClass().getName(), versionManager.getClass().getGenericInterfaces().length));</span>
<span class="fc" id="L771">                LOG.log(Level.FINE, String.format(&quot;The version manager '%s' has '%s' as generic super class&quot;,</span>
<span class="fc" id="L772">                    versionManager.getClass().getName(), versionManager.getClass().getGenericSuperclass()));</span>
            }
<span class="fc bfc" id="L774" title="All 2 branches covered.">            if (accept(className, classLoader, versionManager)) {</span>
<span class="fc" id="L775">                return versionManager;</span>
            }
<span class="fc" id="L777">        }</span>
<span class="fc" id="L778">        return null;</span>
    }

    /**
     * Indicates whether the given {@link VersionManager} matches with the specified criteria.
     * @param className the full qualified name of the application for which we want a version manager.
     * @param classLoader the classloader to use to check the version manager.
     * @param versionManager the version manager to check.
     * @return {@code true} if the version manager matches, {@code false} otherwise.
     * @throws ApplicationException if the version manager could not be checked.
     */
    @SuppressWarnings(&quot;PMD.AvoidLiteralsInIfCondition&quot;)
    private boolean accept(final String className, final ClassLoader classLoader,
                           final VersionManager versionManager) throws ApplicationException {

<span class="fc" id="L793">        final Type[] types = getTypes(versionManager);</span>
<span class="pc bpc" id="L794" title="1 of 2 branches missed.">        if (types.length == 1) {</span>
            final ParameterizedType type;
<span class="fc bfc" id="L796" title="All 2 branches covered.">            if (types[0] instanceof ParameterizedType) {</span>
<span class="fc" id="L797">                type = (ParameterizedType) types[0];</span>
            } else {
<span class="fc" id="L799">                return true;</span>
            }
<span class="fc bfc" id="L801" title="All 2 branches covered.">            if (LOG.isLoggable(Level.FINE)) {</span>
<span class="fc" id="L802">                LOG.log(Level.FINE, String.format(&quot;The version manager '%s' has '%s' type arguments&quot;,</span>
<span class="fc" id="L803">                    versionManager.getClass().getName(), type.getActualTypeArguments().length));</span>
            }
<span class="pc bpc" id="L805" title="1 of 2 branches missed.">            if (type.getActualTypeArguments().length == 1) {</span>
<span class="fc" id="L806">                final Class&lt;?&gt; typeClass = (Class&lt;?&gt;) type.getActualTypeArguments()[0];</span>
<span class="fc bfc" id="L807" title="All 2 branches covered.">                if (LOG.isLoggable(Level.FINE)) {</span>
<span class="fc" id="L808">                    LOG.log(Level.FINE, String.format(&quot;The version manager '%s' is for the type '%s'&quot;,</span>
<span class="fc" id="L809">                        versionManager.getClass().getName(), typeClass));</span>
                }

                try {
<span class="fc" id="L813">                    return typeClass.isAssignableFrom(Class.forName(className, false, classLoader));</span>
<span class="nc" id="L814">                } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L815">                    throw new ApplicationException(String.format(&quot;Could not find the class '%s'&quot;, className), e);</span>
                }
            }
        }
<span class="nc" id="L819">        return false;</span>
    }

    /**
     * Gives the generic types of the specified version manager.
     * @param versionManager the version manager for which we want the generic types.
     * @return the generic types of the provided version manager.
     */
    private Type[] getTypes(final VersionManager versionManager) {
<span class="fc" id="L828">        final Class&lt;?&gt; versionManagerClass = versionManager.getClass();</span>
<span class="fc bfc" id="L829" title="All 2 branches covered.">        if (versionManagerClass.getGenericInterfaces().length == 0) {</span>
<span class="pc bpc" id="L830" title="1 of 2 branches missed.">            if (versionManagerClass.getGenericSuperclass() == null) {</span>
<span class="nc" id="L831">                return new Type[]{};</span>
            } else {
<span class="fc" id="L833">                return new Type[]{versionManagerClass.getGenericSuperclass()};</span>
            }
        } else {
<span class="fc" id="L836">            return versionManagerClass.getGenericInterfaces();</span>
        }
    }

    /**
     * Exit the whole application properly.
     */
    private void exit() {
<span class="fc" id="L844">        executor.stop();</span>
<span class="pc bpc" id="L845" title="1 of 2 branches missed.">        if (getStage() != null) {</span>
<span class="nc" id="L846">            Platform.runLater(() -&gt; {</span>
<span class="nc" id="L847">                getStage().close();</span>
<span class="nc" id="L848">                Platform.exit();</span>
<span class="nc" id="L849">            });</span>
        }
<span class="fc" id="L851">    }</span>

    @Override
    public void onExit() {
        try {
<span class="fc" id="L856">            destroy();</span>
<span class="fc" id="L857">        } catch (ApplicationException e) {</span>
<span class="pc bpc" id="L858" title="1 of 2 branches missed.">            if (LOG.isLoggable(Level.WARNING)) {</span>
<span class="fc" id="L859">                LOG.log(Level.WARNING, &quot;Could not destroy the application on exit.&quot;, e);</span>
            }
<span class="fc" id="L861">        }</span>
<span class="fc" id="L862">        exit();</span>
<span class="fc" id="L863">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>